#60. Дан одновимірний масив з 10 цілих чисел. Підрахуйте найбільше число
#однакових чисел, що йдуть підряд в ньому.

#Підготував Суханов Андрій, 122Б

import numpy as np

while True:
    while True:
        A=np.zeros(10, dtype=int)

        count=0
        for i in range(len(A)): #Отримуємо доступ до елементів матриці А.
            try: #Перевірка на входження чисел.
                A[i]=int(input('Введіть елементи масиву: '))
                continue
            except ValueError:
                print('Input numbers!! ')
                break

        count=1 #Оскільки порівняння починається з елемента\
        #A[i]та порівнюється із наступним A[i+1], то лічильник
        #вже враховує наступні елементи, не включаючи безпосередньо
        #A[i] елемент (тобто рахує тільки наступні).
        #Наприклад, [3,3,3] - count=2. Отже, count починатиметься з 1.
        count1=1
        lst=[]
        lst1=[]
        H=A[::-1]
        for i in range(10): #Отримуємо доступ до елементів матриці А.
            if len(A)!=i+1: #Оскільки ми порівнюємо число по індексу,
                #то A[i+1] зможе працювати до тих пір, поки не дійде
                #до останнього числа, якщо вже дійшло, то програма \
                #видасть помилку, що індекс поза межою осі масиву.
                #Отже, ми обмежуємо цю дію умовою len(A)!=i+1.
                if A[i]==A[i+1]: #Будемо додавати в if однакові \
                    #елементи у лічильник до гілки else - там ми
                    #додамо лічильник у список та "обнулимо" його.
                    #І знову цикл повернеться у гілку if та буде\
                    #порівнювати елементи.
                    count+=1
                else:
                    lst.append(count)
                    count=1
                    
                if H[i]==H[i+1]: #Оскільки у нас обмежена умова: \
                    #len(A)!=i+1, то програма ігнорує останню ітерацію,\
                    #тобто повторення останніх елементів. Аби запобігти
                    #помилці, ми "перевертаємо" наш масив та знову \
                    #проходимось від першого елемента до і-го.
                    count1+=1
                else:
                    lst1.append(count1)
                    count1=1

        lst_common=lst+lst1 #Зробимо конкатенацію списків, щоб знайти у них\
        #максимальну кількість повторень.
        

        if len(set(A))==1:
            print('У масиві всі числа однакові!')
        elif 1 in set(lst_common) and len(set(lst_common))==1:
            print('Не знайдено елементів у масиві, що повторюються!')
        else:
            sor=sorted(lst_common)
            for i in range(len(sor)):
                print(f'У масиві найбільша кількість повторень - {sor[i-1]}.')
                break


        #Чи бажаєте повторити програму?
        result=input('Введіть "1", щоб продовжити, інше - для виходу: ')
        if result=='1':
            continue
        break
    break

            
            
