#57. Відомість на зарплату представлена як дві таблиці. Одна містить
#прізвища працівників цеху, а друга - їх зарплату за поточний місяць. Знайдіть прізвище
#працівника, зарплата якого найменш відхиляється від середньої зарплати всіх
#працівників за поточний місяць. Знайдіть прізвища двох працівників з найбільшою
#заробітною платою. Видаліть з відомості на зарплату відомості про працівника,
#зарплата якого мінімальна.

#Підготував Суханов Андрій Олександрович, 122Б.

import numpy as np #Імпортуємо numpy, random.
import random

while True:
    #Задаємо прізвищами масив праціників цеху.
    A=np.array(['Ivanov', 'Rudchecnko', 'Mazurevich', 'Tikhonov', 'Abramovich'])
    #Генеруємо зарплатні працівникам.
    B=np.array([random.randint(6000, 23000) for i in range(5)])

    #Створимо цикл, щоб вивести всі прізвища робітників у стовпчик (так гарніше).
    for i in range(len(A)):
        print(f'Прізвище робітника {i+1}: {A[i]}')

    print('Зарплатня робітників: ', B)

    print()

    #Знайдемо середнє значення зарплатні всіх робітників, аби у подальшому \
    #знайти таку ЗП робітника, яка найближча до цього значення.
    B_aver=np.mean(B)
    print('Середня зарплатня робітників', B_aver)

    #Відсортуємо масив "B" та впишемо його у дві різні змінні (вони знадобляться\
    #для подальшого блоку коду).
    O_sort=sorted(B)
    B_sort=sorted(B)

    flag=False #Зробимо прапорець False, щоб потім цим скористатись
    for i in range(len(B_sort)):
        k=len(B_sort)//2 #Оскільки середнє значення ЗП всіх робітників \
        #приблизно дорівнює одній із зарплат, то це, більш ймовірно, може бути\
        #зарплатня, яка знаходиться у середині відсортованого масиву, тому ми ділимо\
        #строку на 2. Але, звісно, не факт, що це саме те середнє значення, тому:
        if B_sort[k]>B_aver:
            flag=True #Якщо середина відсортованого масиву більша, ніж середнє значення\
            #усіх ЗП, то ми будемо порівнювати лише два значення із середнім значенням\
            #те, що [k] (тобто середина) та те, що [k-1] (попереднє перед середнім).
            #Це тому, що середнє значення може лежати у діапазоні лише: \
            # B_sort[k-1]<=середнє значення ЗП<=B_sort[k]. Уже [k+1] ніяк не може приблизно\
            #дорівнювати середньому значенню.
        else: #Але якщо, все-таки, значення B_sort[k] мешше середнього значення, то \
            #ми повинні порівнювати три числа, яке ближче до нашого середнього значення:
            # B_sort[k-1], B_sort[k] та B_sort[k+1].
            B_sort[k]=B_aver

    #Знайдемо ще одну середину строки, незалежну від тієї.
    b=len(B_sort)//2
        
    print()

    #Користуємось попередньою умовою:
    if not flag:
        #(ми замінили у попередньому if середину строки\
        #на середнє значення). Тому будемо віднімати від середини строки (сер.знач)
        #кожне із значень. Потім візьмемо їх по модулю і те, яке виявиться мінімальним
        #і буде найближчим до нуля, тобто приблизно дорінювати середній зарплаті.
        previous=B_sort[k]-B_sort[k-1]
        aver=B_aver-O_sort[b] #Ось тут ми використовуємо ту саму змінну, що присвоїли\
        #їй сортований масив, аби дійсно відняти від середнього значення середину строки\
        #масиву B_sort, а не від сер.значення віднімати сер.значення.
        next_i=B_sort[k]-B_sort[k+1]
        f=np.array([abs(previous),abs(aver),abs(next_i)])
        if min(f)==previous:
            print(f'Найбільш наближена зарплатня до середньої: {B_sort[k-1]}.')
        elif min(f)==aver:
            print(f'Найбільш наближена зарплатня до середньої: {O_sort[b]}.')
        else:
            print(f'Найбільш наближена зарплатня до середньої: {B_sort[k+1]}.')

    #Ось тут ми будемо працювати лише з двома числами: [k] та [k-1]. Раніше \
    #я вже пояснив чому.
    else:
        aver=O_sort[b]-B_aver
        previous=B_sort[k-1]-B_aver
        f=np.array([abs(aver),abs(previous)])
        if min(f)==aver:
            print(f'Найбільш наближена зарплатня до середньої: {O_sort[b]}.')
        else:
            print(f'Найбільш наближена зарплатня до середньої: {B_sort[k-1]}.')

    
    b=min(B)#шукаємо найменшу ЗП робітника, щоб видалити його з відомості.
    for i in range(len(A)):
        for j in range(len(B)):
            if b==B[j]:
                i=j #Хочу поєднати прізвище із зарплатнею.
    print(f'Найменша зарплатня {b} у {A[i]}.')
    print('Тому видалимо його із відомості. Нова відомість:')
    print()

    for i in range(len(A)):
        for j in range(len(B)):
            if b==B[j]:
                i=j #Отже, індекси у прізвища і зарплатні рівні, тому видалимо їх.
                A[i]=''
                B[j]=0
    print(A) #Виведемо нові анкети.
    print(B)


    K=A #Для легшого працювання, зробимо поверхневу копію прізвищ робітників.
    for i in range(len(A)):
        for v in range(len(K)):
            for j in range(len(B)):
                #Знайдемо їх найбільші зарплати:
                maxx=sorted(B)[3:]
                min_B=min(maxx)
                max_B=max(maxx)
                #Ось тут знайдемо та виведемо прізвища та ЗП цих робітників.
                if min_B==B[j]:
                    i=j
                else:
                    if max_B==B[j]:
                        v=j
    print(f'Найбільші зарплати {min_B} у {A[i]} та {max_B} у {K[v]}')


    #Чи бажаєте повторити програму?
    result=input('Введіть "1", щоб продовжити, інше - для виходу: ')
    if result=='1':
        continue
    break
            
        




        
