#56. Якщо в одновимірному масиві є три поспіль однакових елемента, то
#змінній r привласнити значення істина.

#Підготував студент 1-го курсу групи 122Б, Суханов Андрій Олександрович.

import numpy as np #Імпортуємо numpy.

while True:
    while True:
        #Ініціалізуємо масив нулями.
        A=np.zeros(8, dtype=int)

        for i in range(len(A)): #Отримуємо доступ до елементів матриці А.
            try: #Перевірка на входження чисел.
                A[i] =int(input('Введіть елементи масиву: '))
                continue
            except ValueError:
                print('Input numbers!! ')
                break

        r=False #Надаємо змінній r значення False.
        count=1 #Оскільки порівняння починається з елемента\
        #A[i]та порівнюється із наступним A[i+1], то лічильник
        #вже враховує наступні елементи, не включаючи безпосередньо
        #A[i] елемент (тобто рахує тільки наступні).
        #Наприклад, [3,3,3] - count=2. Отже, count починатиметься з 1.
        count1=1
        lst=[]
        lst1=[]
        H=A[::-1]
        for i in range(8): #Отримуємо доступ до елементів матриці А.
            if len(A)!=i+1: #Оскільки ми порівнюємо число по індексу,
                #то A[i+1] зможе працювати до тих пір, поки не дійде
                #до останнього числа, якщо вже дійшло, то програма \
                #видасть помилку, що індекс поза межою осі масиву.
                #Отже, ми обмежуємо цю дію умовою len(A)!=i+1.
                if A[i]==A[i+1]: #Будемо додавати в if однакові \
                    #елементи у лічильник до гілки else - там ми
                    #додамо лічильник у список та "обнулимо" його.
                    #І знову цикл повернеться у гілку if та буде\
                    #порівнювати елементи.
                    count+=1
                else:
                    lst.append(count)
                    count=1
                    
                if H[i]==H[i+1]: #Оскільки у нас обмежена умова: \
                    #len(A)!=i+1, то програма ігнорує останню ітерацію,\
                    #тобто повторення останніх елементів. Аби запобігти
                    #помилці, ми "перевертаємо" наш масив та знову \
                    #проходимось від першого елемента до і-го.
                    count1+=1
                else:
                    lst1.append(count1)
                    count1=1

        #Якщо кількість повторень, що дорівнють 3 є у одному з наших
        #списків, то значення r змінюється на True.
        if 3 in lst or 3 in lst1:
            r=True
            print(f'r={r}, оскільки однакове число зустрілось \
три рази поспіль.')
        else:
            print(f'r={r}, оскільки однакове число не зустрілось \
три рази поспіль.')
            

        #Чи бажаєте повторити програму?
        result=input('Введіть "1", щоб продовжити, інше - для виходу: ')
        if result=='1':
            continue
        break
    break
            

        
        




